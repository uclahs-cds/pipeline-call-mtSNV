///// methods invocation ///////
import nextflow.util.SysHelper

methods {
    set_date = {
        def date = new Date().format('yyyyMMdd-HHmmss')
        params.date = "${date}"
    }
    setup = {
        methods.set_date()
        }
}

methods.setup()

///// docker ////////
docker {
    enabled = true
    sudo = (params.sge_scheduler) ? true : false // Set to true if run on SGE
    
    // Pass user's UID/GID and group IDs to Docker
    uid_and_gid = "-u \$(id -u):\$(id -g)"
    all_group_ids = "\$(for i in `id --real --groups`; do echo -n \"--group-add=\$i \"; done)"

    runOptions = "${uid_and_gid} ${all_group_ids}"
    }
  
params.validate_docker_image = "blcdsdockerregistry/validate:2.1.5"
params.BAMQL_docker_image = 'blcdsdockerregistry/bamql:1.6.1'
params.MToolBox_docker_image = 'blcdsdockerregistry/mtoolbox:1.2.1-b52269e'
params.mitocaller_docker_image = 'blcdsdockerregistry/mitocaller:1.0.0'
params.mitoCaller2vcf_docker_image = 'blcdsdockerregistry/mitocaller2vcf:1.0.0'
params.heteroplasmy_script_docker_image = "blcdsdockerregistry/call-heteroplasmy-script:1.0"
 

///// pipeline monitoring and metric files ////////
timeline {
    enabled = true
    file = "${params.output_dir}/${params.run_name}_${params.date}/timeline.html"
}

trace {
    enabled = true
    file = "${params.output_dir}/${params.run_name}_${params.date}/trace.txt"
}

report {
    enabled = true
    file = "${params.output_dir}/${params.run_name}_${params.date}/report.html"
}

////////////// process info /////////////
process {
    // monitor process jobs with local (not slurm) executor
    executor = "local"

    // total amount of resources avaible to the pipeline
    maxForks = params.max_number_of_parallel_jobs

    // echo stdout of each step to stdout of pipeline
    echo = true
    cache = params.cache_intermediate_pipeline_steps
}

//////////// location of Nextflow temp directories /////////
workDir = params.temp_dir
NXF_WORK = params.temp_dir
NXF_TEMP = params.temp_dir
NXF_HOME = params.temp_dir
