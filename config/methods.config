import nextflow.util.SysHelper
includeConfig "${projectDir}/external/pipeline-Nextflow-config/config/methods/common_methods.config"
includeConfig "${projectDir}/external/pipeline-Nextflow-config/config/schema/schema.config"
includeConfig "${projectDir}/external/pipeline-Nextflow-config/config/bam/bam_parser.config"

methods {

    // Function to ensure that resource requirements don't go beyond
    // a maximum limit
    check_max = { obj, type ->
        if (type == 'memory') {
            try {
                if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                    return params.max_memory as nextflow.util.MemoryUnit
                else
                    return obj
            } catch (all) {
                println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
                return obj
                }
        } else if (type == 'time') {
            try {
                if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                    return params.max_time as nextflow.util.Duration
                else
                    return obj
            } catch (all) {
                println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
                return obj
                }
        } else if (type == 'cpus') {
            try {
                return Math.min(obj, params.max_cpus as int)
            } catch (all) {
                println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
                return obj
                }
            }
        }

    sanitize_string = { raw ->
        if (![String, GString].any{ raw in it }) {
            throw new Exception("Input to sanitize is either empty or not a string! Provide a non-empty string.")
            }
        def disallowed_characters = /[^a-zA-Z\d\/_.-]/
        return raw.replaceAll(disallowed_characters, '').replace('_', '-')
    }

    get_ids_from_bams = {
        params.samples_to_process = [] as Set
        params.input.each { k, v ->
            v.each { sampleMap ->
                def bam_path = sampleMap['BAM']
                def bam_header = bam_parser.parse_bam_header(bam_path)
                def sm_tags = bam_header['read_group'].collect{ it['SM'] }.unique()
                if (sm_tags.size() > 1) {
                    throw new Exception("${bam_path} contains multiple samples! Please run pipeline with single sample BAMs.")
                }
                sm_tag = methods.sanitize_string(sm_tags[0])
                params.samples_to_process.add([
                    'orig_id': sm_tags[0],
                    'id': sm_tag,
                    'path': bam_path,
                    'sample_type': k]
                )
            }
        }
    }

    get_id_from_bam = { bam_path ->
        def bam_header = bam_parser.parse_bam_header(bam_path)
        def sm_tags = bam_header['read_group'].collect{ it['SM'] }.unique()
        if (sm_tags.size() > 1) {
            throw new Exception("${bam_path} contains multiple samples! Please run pipeline with single sample BAMs.")
        }
        sm_tag = methods.sanitize_string(sm_tags[0])
        return sm_tag
        }

    prepare_input = {
        // transform input into list format
        params.input_channel_list = []
        params.sample_id = ''
        params.input.each {
            entry ->
            def sample_type = entry.key
            def bam_path = entry.value['BAM']
            def bam_id = methods.get_id_from_bam(bam_path)
            def entry_tuple = [sample_type, bam_id, bam_path]
            params.input_channel_list.add(entry_tuple)
            }
        // set sample mode
        switch (params.input_channel_list.size()) {
            case 0:
                println "   ### ERROR ###   No samples provided"
                break
            case 1:
                params.sample_mode = 'single'
                params.sample_id = params.input_channel_list[0][1]
                break
            case 2:
                params.sample_mode = 'paired'
                params.sample_id = methods.get_id_from_bam(params.input['tumor']['BAM'])
                break
            }
        // create info string for log
        params.input_string = ''
        params.input.each {
            entry ->
            params.input_string <<= entry.key << ": " << entry.value['BAM'] << "\n\s\s\s\s\s\s\s\s"
            }
        params.input_string = params.input_string.toString().trim()
        }

    set_output_dir = {
        def tz = TimeZone.getTimeZone("UTC")
        def date = new Date().format("yyyyMMdd'T'HHmmss'Z'", tz)
        params.date = "${date}"

        params.output_dir_prefix = "${params.output_dir}/${manifest.name}-${manifest.version}/${params.sample_id}"
        params.output_dir_base = "${params.output_dir_prefix}/mitoCaller-${params.mitocaller_version}/"
        params.nextflow_log_dir = "${params.output_dir_prefix}/log-${manifest.name}-${manifest.version}-${date}/"
        params.log_output_dir = "${params.nextflow_log_dir}/process-log/"
        }


    set_pipeline_logs = {
        timeline.enabled = true
        timeline.file = "${params.nextflow_log_dir}/nextflow-log/timeline.html"

        trace.enabled = true
        trace.file = "${params.nextflow_log_dir}/nextflow-log/trace.txt"

        report.enabled = true
        report.file =  "${params.nextflow_log_dir}/nextflow-log/report.html"
        }

    check_workdir_permissions = { dir ->
        dir_file = new File(dir)
        if (dir_file.exists()) {
            if (dir_file.canWrite()) {
                return true
            } else {
                throw new Exception("   ### ERROR ###   The input directory params.work_dir: ${dir} is not writeable. Please verify and try again.")
            }
        } else {
            while (!dir_file.exists()) {
                dir_file = dir_file.getParentFile()
            }

        if (dir_file.canWrite()) {
            return true
        } else {
            throw new Exception("   ### ERROR ###   The input directory params.work_dir: ${dir} cannot be created. The closest existing parent directory ${dir_file.toString()} is not writable. Please verify permissions or change the input parameter.")
        }
        }
    }


    setup = {
        schema.load_custom_types("${projectDir}/external/pipeline-Nextflow-config/config/schema/custom_schema_types.config")
        schema.validate()
        methods.set_resources_allocation()
        methods.prepare_input()
        methods.set_output_dir()
        methods.set_pipeline_logs()
        methods.set_env()
        }
    }



